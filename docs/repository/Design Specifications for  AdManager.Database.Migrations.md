# Software Design Specification: AdManager.Database.Migrations

## 1. Introduction

### 1.1. Purpose
This document provides the software design specification for the `AdManager.Database.Migrations` repository. This repository is responsible for managing and versioning the database schema of the Ad Manager platform's PostgreSQL database, which is managed by Amazon RDS. It utilizes TypeORM's migration capabilities to ensure a consistent and controlled evolution of the database structure across all environments (development, testing, production).

This repository also provides a mechanism for seeding initial or lookup data into the database.

### 1.2. Scope
The scope of this repository includes:
*   Defining and managing TypeORM data source configurations for connecting to the PostgreSQL database.
*   Creating and maintaining versioned migration scripts written in TypeScript to define schema changes (table creation, alteration, deletion, index creation, etc.).
*   Providing CLI commands (via `package.json` scripts) to generate, run, and revert migrations.
*   Implementing seed scripts to populate essential lookup data or initial administrative data.
*   Ensuring that schema changes are trackable, reversible (where feasible), and deployable in a consistent manner.

While the repository description mentions potential scripts for DynamoDB, the current file structure and design primarily focus on PostgreSQL migrations. Any DynamoDB schema management or seeding would be an extension and is not detailed in this initial SDS unless specific files for it are introduced.

### 1.3. Requirements Addressed
This repository primarily addresses the following requirements:
*   `REQ-3.2.7`: Maintainability - Database schema changes managed by migration tools.
*   `REQ-3.4.1`: Data Model - Relational Data - schema changes. (Specifically, implementing the PostgreSQL schema detailed in the overall "Database Design" section).

## 2. Technologies Used
*   **Programming Language**: TypeScript (v5.3.3)
*   **Framework/ORM**: TypeORM (v0.3.20)
*   **Database**: PostgreSQL (v16.2 target)
*   **Runtime**: Node.js (v20.11.1 LTS)
*   **CLI**: TypeORM CLI
*   **Package Manager**: npm or yarn (assumed, based on `package.json`)
*   **Environment Management**: `dotenv` for loading environment variables.

## 3. System Architecture Context
This repository is a crucial part of the **Data Persistence Layer** within the Ad Manager platform's architecture. It ensures that the relational database schema (PostgreSQL_AdManagerDB) is correctly provisioned and updated as the platform evolves. It directly interacts with the PostgreSQL database instance.

## 4. Core Functionality

### 4.1. Database Schema Migration
The primary functionality is to manage database schema changes over time.
*   **Version Control**: Migrations are version-controlled files, allowing tracking of schema history.
*   **Automated Changes**: TypeORM CLI executes these migrations to apply changes to the database.
*   **Consistency**: Ensures database schema is consistent across different deployment environments.

### 4.2. Data Seeding
Secondary functionality includes populating the database with initial data required for the application to function correctly (e.g., predefined roles, subscription plans).

## 5. Design Considerations

### 5.1. Migration Generation
*   Migrations can be auto-generated by TypeORM CLI based on entity changes (if entities are defined in the `data-source.ts` or related projects) or manually created. For this repository, it's assumed migrations are often manually crafted SQL within TypeORM's migration structure or use `QueryRunner` for more complex DDL.
*   Command: `npm run typeorm -- migration:generate database/migrations/MyNewMigration` (or similar script in `package.json`).

### 5.2. Migration Execution
*   Migrations are executed sequentially based on their timestamps (part of the filename).
*   TypeORM keeps track of executed migrations in a dedicated table (`custom_migrations_table` as per `data-source.ts` description).
*   Command: `npm run typeorm -- migration:run -d data-source.ts` (or similar script).

### 5.3. Migration Reversion
*   Each migration script includes a `down` method to revert the changes made by the `up` method.
*   Command: `npm run typeorm -- migration:revert -d data-source.ts` (or similar script).

### 5.4. Migration Naming Convention
*   Migrations should follow the `<timestamp>-<DescriptiveName>.ts` convention (e.g., `1000000000000-CreateBaseInfrastructureTables.ts`). The timestamp ensures chronological order.

### 5.5. Idempotency
While TypeORM handles running migrations only once, the SQL within `up` and `down` methods should be written carefully, especially if manual checks are involved (e.g., `IF NOT EXISTS` for table creation, though `QueryRunner.createTable` handles this).

### 5.6. Error Handling
Migrations should be transactional if possible. If a migration fails, TypeORM should ideally roll back the changes made by that specific migration script. The `up` and `down` methods are `async` and should properly handle promises and throw errors on failure.

### 5.7. Configuration (`data-source.ts`)
The `data-source.ts` file is central to TypeORM CLI operations. It must:
*   Correctly configure the PostgreSQL connection using environment variables for sensitive data.
*   Specify the path to migration files.
*   Set `synchronize: false` to ensure migrations are the sole source of schema truth.
*   Define the custom migrations table name.

### 5.8. Data Seeding Approach
*   Seed scripts are separate TypeScript files.
*   A custom script or a seeder library (e.g. `typeorm-seeding` adapted for TypeORM 0.3.x, or a simpler custom runner) will be used to execute these seed files. The `package.json` should include a script like `npm run seed:run`.
*   Seed scripts typically fetch the `DataSource` instance to interact with the database.
*   They should be designed to be re-runnable without causing duplicate data issues (e.g., by checking for existing data before inserting).

## 6. Detailed Design of Components (Files)

### 6.1. `package.json`
*   **Purpose**: Manages project dependencies and provides scripts for common tasks.
*   **Dependencies**:
    *   `typeorm`: Core TypeORM library.
    *   `pg`: PostgreSQL driver for Node.js.
    *   `typescript`: TypeScript compiler.
    *   `ts-node`: To run TypeScript files directly.
    *   `dotenv`: For loading environment variables from a `.env` file.
    *   `@types/node`, `@types/pg` (devDependencies).
*   **Scripts**:
    *   `build`: `tsc` (compiles TypeScript to JavaScript).
    *   `typeorm`: `ts-node ./node_modules/typeorm/cli.js` (base command for TypeORM CLI).
    *   `migration:generate`: `npm run typeorm -- migration:generate -d data-source.ts database/migrations/$NAME` (replace $NAME with migration name).
    *   `migration:run`: `npm run typeorm -- migration:run -d data-source.ts`.
    *   `migration:revert`: `npm run typeorm -- migration:revert -d data-source.ts`.
    *   `migration:show`: `npm run typeorm -- migration:show -d data-source.ts`.
    *   `seed:run`: (Assumes a custom script or seeder runner integration) `ts-node ./path/to/seed-runner.ts` or similar.

### 6.2. `tsconfig.json`
*   **Purpose**: Configures the TypeScript compiler.
*   **Key Compiler Options**:
    *   `target`: "ES2021" or newer.
    *   `module`: "commonjs".
    *   `outDir`: "./dist" (output directory for compiled JavaScript).
    *   `rootDir`: "./" (root directory of source files).
    *   `strict`: `true`.
    *   `esModuleInterop`: `true`.
    *   `experimentalDecorators`: `true`.
    *   `emitDecoratorMetadata`: `true`.
    *   `resolveJsonModule`: `true`.
    *   `sourceMap`: `true` (for easier debugging).
*   **Include/Exclude**:
    *   `include`: `["data-source.ts", "database/migrations/**/*.ts", "database/seeds/**/*.ts", "path/to/seed-runner.ts" (if applicable)]`.
    *   `exclude`: `["node_modules", "dist"]`.

### 6.3. `data-source.ts`
*   **Purpose**: Provides TypeORM with database connection details and paths to migration files.
*   **Implementation**:
    typescript
    import 'dotenv/config';
    import { DataSource, DataSourceOptions } from 'typeorm';
    import path from 'path';

    export const dataSourceOptions: DataSourceOptions = {
        type: 'postgres',
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432', 10),
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_DATABASE_NAME,
        synchronize: false, // CRITICAL: always false for migration-managed schemas
        logging: process.env.NODE_ENV === 'development' ? true : ['error'], // Log all queries in dev, only errors in prod
        entities: [], // Entities are usually defined in the main application, not needed here for CLI if migrations use raw SQL or QueryBuilder directly.
                      // If using entities to auto-generate migrations, they would be listed here.
        migrations: [path.join(__dirname, '/migrations/**/*{.ts,.js}')], // Path to migration files
        migrationsTableName: 'custom_migrations_table', // Custom name for the migrations history table
        // ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : undefined, // Optional: for SSL connections
    };

    const AppDataSource = new DataSource(dataSourceOptions);

    export default AppDataSource;
    
*   **Environment Variables**: Requires `.env` file or environment variables for:
    *   `DB_HOST`
    *   `DB_PORT`
    *   `DB_USERNAME`
    *   `DB_PASSWORD`
    *   `DB_DATABASE_NAME`
    *   `NODE_ENV` (optional, for conditional logging)
    *   `DB_SSL` (optional)

### 6.4. Migration Scripts (`database/migrations/`)

All migration scripts will implement `MigrationInterface` from `typeorm`.

typescript
import { MigrationInterface, QueryRunner, Table, TableForeignKey, TableIndex, TableColumn } from "typeorm";

export class MigrationTimestampAndName implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // Implementation using queryRunner.query("RAW SQL"), queryRunner.createTable, etc.
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        // Implementation to revert changes made in 'up'
    }
}


#### 6.4.1. `1000000000000-CreateBaseInfrastructureTables.ts`
*   **Purpose**: Creates foundational tables: `Merchant`, `UserRole`, `AdManagerUser`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `Merchant` table:
        *   `id`: `UUID`, Primary Key, `uuid_generate_v4()` default.
        *   Other merchant-specific columns as per global Database Design (e.g., `name VARCHAR`, `corePlatformMerchantId UUID UNIQUE`, `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`).
    *   Create `UserRole` table:
        *   `id`: `UUID`, Primary Key, `uuid_generate_v4()` default.
        *   `name`: `VARCHAR(50)`, Unique, Not Null (e.g., 'Merchant Admin', 'Campaign Manager', 'Platform Administrator').
        *   `description`: `TEXT`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `AdManagerUser` table:
        *   `id`: `UUID`, Primary Key, `uuid_generate_v4()` default.
        *   `coreUserId`: `UUID`, Unique, Not Null (links to `CoreUser` entity in the conceptual model).
        *   `merchantId`: `UUID`, Not Null, Foreign Key references `Merchant(id)` ON DELETE CASCADE.
        *   `roleId`: `UUID`, Not Null, Foreign Key references `UserRole(id)` ON DELETE RESTRICT.
        *   `isActive`: `BOOLEAN`, Not Null, Default `true`.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Add necessary indexes (e.g., on FK columns).
*   **`down(queryRunner: QueryRunner)`**:
    *   Drop `AdManagerUser` table.
    *   Drop `UserRole` table.
    *   Drop `Merchant` table.

#### 6.4.2. `1000000000001-CreateCampaignManagementTables.ts`
*   **Purpose**: Creates tables for campaign management: `Campaign`, `AdNetwork`, `CampaignAdNetwork`, `AdSet`, `AdCreative`, `Ad`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `AdNetwork` table:
        *   `id`: `UUID`, PK.
        *   `name`: `VARCHAR(100)`, Unique, Not Null (e.g., 'Google Ads', 'Instagram Ads').
        *   `apiEndpoint`: `VARCHAR(255)`, Nullable.
        *   `iconUrl`: `VARCHAR(255)`, Nullable.
        *   `isEnabled`: `BOOLEAN`, Default `true`.
    *   Create `Campaign` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `budget`: `DECIMAL(19,4)`, Nullable.
        *   `startDate`: `TIMESTAMPTZ`, Nullable.
        *   `endDate`: `TIMESTAMPTZ`, Nullable.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Draft', 'Active', 'Paused', 'Archived'). ENUM type preferred if DB supports it well with TypeORM.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `CampaignAdNetwork` (join table):
        *   `campaignId`: `UUID`, PK, FK to `Campaign(id)` ON DELETE CASCADE.
        *   `adNetworkId`: `UUID`, PK, FK to `AdNetwork(id)` ON DELETE CASCADE.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Linked', 'Syncing', 'Error').
        *   `adNetworkCampaignId`: `VARCHAR(255)`, Nullable (ID from the actual ad network).
    *   Create `AdCreative` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `adNetworkId`: `UUID`, FK to `AdNetwork(id)` ON DELETE RESTRICT. (Or nullable if creative can be network-agnostic initially).
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `type`: `VARCHAR(50)`, Not Null (e.g., 'Image', 'Video', 'TextAd', 'Carousel').
        *   `contentUrl`: `VARCHAR(1024)`, Nullable (for image/video assets).
        *   `adCopyText`: `TEXT`, Nullable.
        *   `headline`: `VARCHAR(255)`, Nullable.
        *   `validationStatus`: `VARCHAR(50)`, Default `'Pending'` (e.g., 'Pending', 'Approved', 'Rejected').
        *   `adNetworkCreativeId`: `VARCHAR(255)`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `AdSet` table:
        *   `id`: `UUID`, PK.
        *   `campaignId`: `UUID`, FK to `Campaign(id)` ON DELETE CASCADE.
        *   `adNetworkId`: `UUID`, FK to `AdNetwork(id)` ON DELETE RESTRICT. (Ensure this aligns with campaign's chosen networks).
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `budgetType`: `VARCHAR(50)`, Nullable (e.g., 'Daily', 'Lifetime').
        *   `budgetAmount`: `DECIMAL(19,4)`, Nullable.
        *   `targetingCriteria`: `JSONB`, Nullable (for demographics, interests, etc.).
        *   `biddingStrategy`: `VARCHAR(100)`, Nullable.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Active', 'Paused').
        *   `adNetworkAdSetId`: `VARCHAR(255)`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Ad` table:
        *   `id`: `UUID`, PK.
        *   `adSetId`: `UUID`, FK to `AdSet(id)` ON DELETE CASCADE.
        *   `adCreativeId`: `UUID`, FK to `AdCreative(id)` ON DELETE RESTRICT.
        *   `promotionId`: `UUID`, Nullable, FK to `Promotion(id)` (created in a later migration) ON DELETE SET NULL. *Defer FK constraint or add later if Promotion table doesn't exist yet.*
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `destinationUrl`: `VARCHAR(2048)`, Nullable.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Active', 'Paused', 'InReview').
        *   `adNetworkAdId`: `VARCHAR(255)`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
*   **`down(queryRunner: QueryRunner)`**: Drop tables in reverse order: `Ad`, `AdSet`, `AdCreative`, `CampaignAdNetwork`, `Campaign`, `AdNetwork`.

#### 6.4.3. `1000000000002-CreateProductCatalogTables.ts`
*   **Purpose**: Creates tables for product catalogs: `ProductCatalog`, `Product`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `ProductCatalog` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Active', 'Inactive', 'Syncing').
        *   `sourcePlatform`: `VARCHAR(100)`, Nullable (e.g., 'PlatformNameCore', 'CSVImport').
        *   `lastSyncedAt`: `TIMESTAMPTZ`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Product` table (representing products within an Ad Manager catalog, potentially with overrides):
        *   `id`: `UUID`, PK.
        *   `productCatalogId`: `UUID`, FK to `ProductCatalog(id)` ON DELETE CASCADE.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `coreProductId`: `UUID`, Nullable (ID from `[PlatformName]` core e-commerce platform). Could be `VARCHAR` if IDs are not UUIDs.
        *   `sku`: `VARCHAR(100)`, Nullable.
        *   `title`: `VARCHAR(255)`, Not Null.
        *   `description`: `TEXT`, Nullable.
        *   `price`: `DECIMAL(19,4)`, Nullable.
        *   `imageUrl`: `VARCHAR(1024)`, Nullable.
        *   `productUrl`: `VARCHAR(2048)`, Nullable.
        *   `stockLevel`: `INTEGER`, Nullable.
        *   `adSpecificTitle`: `VARCHAR(255)`, Nullable (override for ads).
        *   `adSpecificDescription`: `TEXT`, Nullable (override for ads).
        *   `customAttributes`: `JSONB`, Nullable (for ad network specific fields).
        *   `isOverride`: `BOOLEAN`, Default `false`.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
        *   Index on `(productCatalogId, coreProductId)` or `(productCatalogId, sku)`.
*   **`down(queryRunner: QueryRunner)`**: Drop `Product`, then `ProductCatalog`.

#### 6.4.4. `1000000000003-CreatePromotionTables.ts`
*   **Purpose**: Creates tables for promotions: `Promotion`, `DiscountCode`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `Promotion` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `description`: `TEXT`, Nullable.
        *   `type`: `VARCHAR(50)`, Not Null (e.g., 'PercentageOff', 'FixedAmountOff', 'BOGO', 'QuantityDiscount').
        *   `value`: `DECIMAL(19,4)`, Nullable (for fixed amount or percentage).
        *   `minimumPurchaseAmount`: `DECIMAL(19,4)`, Nullable.
        *   `startDate`: `TIMESTAMPTZ`, Nullable.
        *   `endDate`: `TIMESTAMPTZ`, Nullable.
        *   `isActive`: `BOOLEAN`, Default `true`.
        *   `usageLimit`: `INTEGER`, Nullable (total uses).
        *   `usageLimitPerCustomer`: `INTEGER`, Nullable.
        *   `eligibilityCriteria`: `JSONB`, Nullable (e.g., customer segments, specific products).
        *   `stackingRules`: `JSONB`, Nullable (how it interacts with other promotions).
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `DiscountCode` table:
        *   `id`: `UUID`, PK.
        *   `promotionId`: `UUID`, FK to `Promotion(id)` ON DELETE CASCADE.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `code`: `VARCHAR(100)`, Not Null. Unique constraint `(merchantId, code)`.
        *   `isActive`: `BOOLEAN`, Default `true`.
        *   `expirationDate`: `TIMESTAMPTZ`, Nullable.
        *   `usageLimit`: `INTEGER`, Nullable (uses for this specific code).
        *   `timesUsed`: `INTEGER`, Default `0`.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Add Foreign Key to `Ad` table for `promotionId` if not already done or if it was deferred:
        typescript
        // await queryRunner.addForeignKey("Ad", new TableForeignKey({
        //     columnNames: ["promotionId"],
        //     referencedColumnNames: ["id"],
        //     referencedTableName: "Promotion",
        //     onDelete: "SET NULL"
        // }));
        
        (Consider if this FK was already created in the CampaignManagementTables migration. If so, this step is not needed. If Promotion was created after Ad, this is the place to add it.)
*   **`down(queryRunner: QueryRunner)`**: Drop `DiscountCode`, then `Promotion`. (And `ALTER TABLE "Ad" DROP CONSTRAINT FK_Ad_Promotion` if added here).

#### 6.4.5. `1000000000004-CreateABTestingTables.ts`
*   **Purpose**: Creates table for A/B test configurations: `ABTest`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `ABTest` table:
        *   `id`: `UUID`, PK.
        *   `campaignId`: `UUID`, FK to `Campaign(id)` ON DELETE CASCADE.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `description`: `TEXT`, Nullable.
        *   `testType`: `VARCHAR(100)`, Not Null (e.g., 'CreativeTest', 'CopyTest', 'LandingPageTest', 'OfferTest').
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Draft', 'Running', 'Paused', 'Completed').
        *   `startDate`: `TIMESTAMPTZ`, Nullable.
        *   `endDate`: `TIMESTAMPTZ`, Nullable.
        *   `controlVariantId`: `UUID`, Nullable (if one variant is designated as control).
        *   `variantsConfiguration`: `JSONB`, Not Null (stores info about each variant, e.g., { variantA: { creativeId: '...', weight: 50 }, variantB: { creativeId: '...', weight: 50 } }).
        *   `winningVariantId`: `UUID`, Nullable.
        *   `significanceLevel`: `FLOAT`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
*   **`down(queryRunner: QueryRunner)`**: Drop `ABTest` table.

#### 6.4.6. `1000000000005-CreateAudienceAndContentTables.ts`
*   **Purpose**: Creates tables for audiences, landing pages, SEO settings: `Audience`, `LandingPage`, `SeoSetting`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `Audience` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `type`: `VARCHAR(50)`, Not Null (e.g., 'Custom', 'Lookalike', 'InterestBased').
        *   `source`: `VARCHAR(100)`, Nullable (e.g., 'PlatformNameCustomers', 'PixelData', 'ManualUpload').
        *   `description`: `TEXT`, Nullable.
        *   `adNetworkAudienceId`: `VARCHAR(255)`, Nullable (ID on the ad network).
        *   `size`: `INTEGER`, Nullable.
        *   `status`: `VARCHAR(50)`, Nullable (e.g., 'Active', 'Syncing').
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `LandingPage` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `campaignId`: `UUID`, Nullable, FK to `Campaign(id)` ON DELETE SET NULL.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `title`: `VARCHAR(255)`, Not Null (for HTML title tag).
        *   `urlSlug`: `VARCHAR(255)`, Not Null. Unique constraint `(merchantId, urlSlug)`.
        *   `metaDescription`: `TEXT`, Nullable.
        *   `content`: `JSONB`, Not Null (structure for page builder elements like banners, timers, CTAs).
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Draft', 'Published', 'Archived').
        *   `isSeoFriendly`: `BOOLEAN`, Default `true`.
        *   `pageSpeedScoreMobile`: `INTEGER`, Nullable.
        *   `pageSpeedScoreDesktop`: `INTEGER`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `SeoSetting` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `pageType`: `VARCHAR(50)`, Not Null (e.g., 'Product', 'Collection', 'BlogPage', 'LandingPage', 'Homepage').
        *   `coreEntityId`: `UUID`, Nullable (FK to Product, LandingPage, etc., or a generic ID).
        *   `metaTitle`: `VARCHAR(255)`, Nullable.
        *   `metaDescription`: `TEXT`, Nullable.
        *   `seoKeywords`: `TEXT`, Nullable.
        *   `canonicalUrl`: `VARCHAR(2048)`, Nullable.
        *   `schemaMarkup`: `JSONB`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
        *   Unique constraint `(merchantId, pageType, coreEntityId)` (if `coreEntityId` is consistently used).
*   **`down(queryRunner: QueryRunner)`**: Drop `SeoSetting`, `LandingPage`, `Audience`.

#### 6.4.7. `1000000000006-CreatePerformanceAndAffiliateTables.ts`
*   **Purpose**: Creates tables for performance summaries and affiliate marketing: `DailyCampaignPerformanceSummary`, `AffiliateProgram`, `Affiliate`, `AffiliateConversion`, `AffiliatePayout`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `DailyCampaignPerformanceSummary` table:
        *   `date`: `DATE`, PK.
        *   `campaignId`: `UUID`, PK, FK to `Campaign(id)` ON DELETE CASCADE.
        *   `adNetworkId`: `UUID`, PK, FK to `AdNetwork(id)` ON DELETE CASCADE.
        *   `merchantId`: `UUID`, PK, FK to `Merchant(id)` ON DELETE CASCADE. (Consider if merchantId is needed if Campaign already has it, but can be useful for direct queries).
        *   `adSetId`: `UUID`, Nullable (if summarizing at ad set level). PK if so. FK to `AdSet(id)`.
        *   `adId`: `UUID`, Nullable (if summarizing at ad level). PK if so. FK to `Ad(id)`.
        *   `totalImpressions`: `BIGINT`, Default `0`.
        *   `totalClicks`: `BIGINT`, Default `0`.
        *   `totalConversions`: `BIGINT`, Default `0`.
        *   `totalSpend`: `DECIMAL(19,4)`, Default `0`.
        *   `roas`: `DECIMAL(10,4)`, Nullable.
        *   `cpa`: `DECIMAL(19,4)`, Nullable.
        *   `ctr`: `DECIMAL(7,4)`, Nullable.
        *   `conversionRate`: `DECIMAL(7,4)`, Nullable.
        *   `reach`: `BIGINT`, Nullable.
        *   `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `AffiliateProgram` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null.
        *   `description`: `TEXT`, Nullable.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Active', 'Inactive').
        *   `commissionType`: `VARCHAR(50)`, Not Null (e.g., 'PercentageOfSale', 'FlatFeePerConversion').
        *   `commissionRate`: `DECIMAL(10,4)`, Nullable (percentage or flat amount).
        *   `cookieWindowDays`: `INTEGER`, Default `30`.
        *   `termsAndConditionsUrl`: `VARCHAR(2048)`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Affiliate` table:
        *   `id`: `UUID`, PK.
        *   `affiliateProgramId`: `UUID`, FK to `AffiliateProgram(id)` ON DELETE CASCADE.
        *   `coreUserId`: `UUID`, Not Null, Unique (links to external user system, e.g., `[PlatformName]` core user).
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'PendingApproval', 'Active', 'Rejected', 'Suspended').
        *   `trackingCode`: `VARCHAR(100)`, Unique, Not Null.
        *   `paymentDetails`: `JSONB`, Nullable (e.g., PayPal email, bank info).
        *   `approvedAt`: `TIMESTAMPTZ`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `AffiliateConversion` table:
        *   `id`: `UUID`, PK.
        *   `affiliateId`: `UUID`, FK to `Affiliate(id)` ON DELETE CASCADE.
        *   `coreOrderId`: `UUID`, Unique, Not Null (links to `[PlatformName]` core order).
        *   `conversionTimestamp`: `TIMESTAMPTZ`, Not Null, Default `NOW()`.
        *   `saleAmount`: `DECIMAL(19,4)`, Not Null.
        *   `commissionAmount`: `DECIMAL(19,4)`, Not Null.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Pending', 'Approved', 'Rejected', 'Paid').
        *   `affiliatePayoutId`: `UUID`, Nullable, FK to `AffiliatePayout(id)` ON DELETE SET NULL.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `AffiliatePayout` table:
        *   `id`: `UUID`, PK.
        *   `affiliateId`: `UUID`, FK to `Affiliate(id)` ON DELETE CASCADE.
        *   `paymentPeriodStartDate`: `DATE`, Not Null.
        *   `paymentPeriodEndDate`: `DATE`, Not Null.
        *   `totalCommissionAmount`: `DECIMAL(19,4)`, Not Null.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Pending', 'Processing', 'Paid', 'Failed').
        *   `paymentDate`: `TIMESTAMPTZ`, Nullable.
        *   `transactionReference`: `VARCHAR(255)`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
*   **`down(queryRunner: QueryRunner)`**: Drop tables in reverse order.

#### 6.4.8. `1000000000007-CreateBillingAndPlatformTables.ts`
*   **Purpose**: Creates tables for billing, platform config, audit: `SubscriptionPlan`, `Subscription`, `Invoice`, `Payment`, `GiftOption`, `IntegrationConfig`, `AuditLog`, `ConfigurationSetting`.
*   **`up(queryRunner: QueryRunner)`**:
    *   Create `SubscriptionPlan` table:
        *   `id`: `UUID`, PK.
        *   `name`: `VARCHAR(100)`, Unique, Not Null (e.g., 'Basic', 'Pro', 'Plus').
        *   `description`: `TEXT`, Nullable.
        *   `monthlyPrice`: `DECIMAL(10,2)`, Not Null.
        *   `annualPrice`: `DECIMAL(10,2)`, Nullable.
        *   `features`: `JSONB`, Nullable (list of features or limits).
        *   `isActive`: `BOOLEAN`, Default `true`.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Subscription` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, Unique, FK to `Merchant(id)` ON DELETE CASCADE. (One active subscription per merchant).
        *   `planId`: `UUID`, FK to `SubscriptionPlan(id)` ON DELETE RESTRICT.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Active', 'PendingPayment', 'Cancelled', 'Expired').
        *   `startDate`: `TIMESTAMPTZ`, Not Null.
        *   `endDate`: `TIMESTAMPTZ`, Nullable (for fixed-term or cancelled subs).
        *   `nextBillingDate`: `DATE`, Nullable.
        *   `billingCycle`: `VARCHAR(20)`, Not Null (e.g., 'Monthly', 'Annually').
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Invoice` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `subscriptionId`: `UUID`, Nullable, FK to `Subscription(id)` ON DELETE SET NULL.
        *   `invoiceNumber`: `VARCHAR(100)`, Unique.
        *   `issueDate`: `DATE`, Not Null, Default `CURRENT_DATE`.
        *   `dueDate`: `DATE`, Not Null.
        *   `amount`: `DECIMAL(10,2)`, Not Null.
        *   `taxAmount`: `DECIMAL(10,2)`, Default `0`.
        *   `totalAmount`: `DECIMAL(10,2)`, Not Null.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Draft', 'Sent', 'Paid', 'Overdue', 'Void').
        *   `notes`: `TEXT`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `Payment` table:
        *   `id`: `UUID`, PK.
        *   `invoiceId`: `UUID`, FK to `Invoice(id)` ON DELETE CASCADE.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `paymentDate`: `TIMESTAMPTZ`, Not Null, Default `NOW()`.
        *   `amount`: `DECIMAL(10,2)`, Not Null.
        *   `paymentMethod`: `VARCHAR(100)`, Not Null (e.g., 'CreditCard', 'PayPal', 'Mada').
        *   `gatewayTransactionId`: `VARCHAR(255)`, Unique, Nullable.
        *   `status`: `VARCHAR(50)`, Not Null (e.g., 'Succeeded', 'Pending', 'Failed').
        *   `notes`: `TEXT`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `GiftOption` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `name`: `VARCHAR(255)`, Not Null (e.g., 'Custom Gift Note', 'Branded Gift Card Design A').
        *   `type`: `VARCHAR(50)`, Not Null (e.g., 'Note', 'CardDesign').
        *   `description`: `TEXT`, Nullable.
        *   `isEnabled`: `BOOLEAN`, Default `true`.
        *   `configuration`: `JSONB`, Nullable (e.g., for card design URL, note character limit).
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
    *   Create `IntegrationConfig` table:
        *   `id`: `UUID`, PK.
        *   `merchantId`: `UUID`, FK to `Merchant(id)` ON DELETE CASCADE.
        *   `integrationType`: `VARCHAR(100)`, Not Null (e.g., 'GoogleAds', 'FacebookAds', 'TikTokAds', 'PaymentGatewayX', 'ShippingProviderY').
        *   `configuration`: `JSONB`, Not Null (encrypted if sensitive, or use AWS Secrets Manager and store reference).
        *   `isEnabled`: `BOOLEAN`, Default `true`.
        *   `lastSyncStatus`: `VARCHAR(50)`, Nullable.
        *   `lastSyncTimestamp`: `TIMESTAMPTZ`, Nullable.
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
        *   Unique constraint `(merchantId, integrationType)`.
    *   Create `AuditLog` table:
        *   `id`: `BIGSERIAL`, PK (Using BIGSERIAL for high volume potential).
        *   `timestamp`: `TIMESTAMPTZ`, Not Null, Default `NOW()`.
        *   `adManagerUserId`: `UUID`, Nullable, FK to `AdManagerUser(id)` ON DELETE SET NULL (for user actions).
        *   `merchantId`: `UUID`, Nullable, FK to `Merchant(id)` ON DELETE SET NULL (context).
        *   `action`: `VARCHAR(255)`, Not Null (e.g., 'CampaignCreated', 'UserLoginFailed', 'SettingChanged').
        *   `entityType`: `VARCHAR(100)`, Nullable (e.g., 'Campaign', 'UserRole').
        *   `entityId`: `VARCHAR(255)`, Nullable (ID of the affected entity).
        *   `details`: `JSONB`, Nullable (e.g., old value, new value).
        *   `ipAddress`: `VARCHAR(45)`, Nullable.
    *   Create `ConfigurationSetting` table (for platform-wide or merchant-overrideable settings):
        *   `id`: `UUID`, PK.
        *   `key`: `VARCHAR(255)`, Unique, Not Null (e.g., 'DefaultGracePeriodDays', 'MaxCampaignsPerProPlan').
        *   `value`: `TEXT`, Not Null.
        *   `description`: `TEXT`, Nullable.
        *   `isMerchantOverridable`: `BOOLEAN`, Default `false`.
        *   `merchantId`: `UUID`, Nullable, FK to `Merchant(id)` ON DELETE CASCADE (used if `isMerchantOverridable` is true and this is an override).
        *   `createdAt TIMESTAMPTZ DEFAULT NOW()`, `updatedAt TIMESTAMPTZ DEFAULT NOW()`.
        *   If `merchantId` is part of the key, unique constraint on `(key, merchantId)`. If global keys are unique, then `key` is unique for global, and `(key, merchantId)` for overrides. Simpler might be just `key` unique and handle overrides at application level or have a separate `MerchantConfigurationSetting` table. The file structure suggests a single `ConfigurationSetting` table with an optional `merchantId` for overrides, so `(key, merchantId)` combined might act as logical unique key where `merchantId` being NULL means global. A unique index on `key` where `merchantId IS NULL` and another on `(key, merchantId)` where `merchantId IS NOT NULL`.
*   **`down(queryRunner: QueryRunner)`**: Drop tables in reverse order.

### 6.5. Seed Scripts (`database/seeds/`)

Seed scripts are generally run after migrations to populate initial data. The implementation details depend on the chosen seeder runner. Assuming a structure similar to `typeorm-seeding` or a custom runner that takes a `DataSource`.

#### 6.5.1. `01-UserRoles.seed.ts`
*   **Purpose**: Populates the `UserRole` table with essential system roles.
*   **`run(dataSource: DataSource, factory: SeederFactory | undefined)`**:
    typescript
    import { DataSource } from "typeorm";
    // import { Seeder, SeederFactoryManager } from 'typeorm-extension'; // Example if using typeorm-extension
    // Or a custom interface if using a custom runner
    // For TypeORM v0.3.x, direct use of DataSource is common for custom seeders.

    interface UserRoleData {
        id?: string; // Optional if DB generates UUID
        name: string;
        description: string;
    }

    export class UserRolesSeed /* implements Seeder */ { // Adapt to seeder library if used
        public async run(dataSource: DataSource /*, factoryManager?: SeederFactoryManager */): Promise<any> {
            const userRoleRepository = dataSource.getRepository('UserRole'); // Assuming 'UserRole' is an entity name or table name string

            const rolesToSeed: UserRoleData[] = [
                { name: 'Platform Administrator', description: 'Full system-wide access for maintenance, support, and oversight.' },
                { name: 'Merchant Admin', description: 'Full access to their merchant account\'s Ad Manager functionalities.' },
                { name: 'Campaign Manager', description: 'Access limited to campaign and promotion management for their merchant account.' },
            ];

            for (const roleData of rolesToSeed) {
                const existingRole = await userRoleRepository.findOneBy({ name: roleData.name });
                if (!existingRole) {
                    // If 'UserRole' entity is defined and used by repository:
                    // const newRole = userRoleRepository.create(roleData);
                    // await userRoleRepository.save(newRole);
                    // If using QueryBuilder or raw SQL because entities are not defined in this project:
                    await dataSource.createQueryBuilder()
                        .insert()
                        .into('UserRole') // Use actual table name string
                        .values(roleData)
                        .orIgnore() // Or use ON CONFLICT DO NOTHING if preferred and supported
                        .execute();
                    console.log(`Seeded role: ${roleData.name}`);
                } else {
                    console.log(`Role already exists: ${roleData.name}`);
                }
            }
        }
    }
    

#### 6.5.2. `02-InitialSubscriptionPlans.seed.ts`
*   **Purpose**: Populates the `SubscriptionPlan` table with initial plan offerings.
*   **`run(dataSource: DataSource, factory: SeederFactory | undefined)`**:
    typescript
    import { DataSource } from "typeorm";

    interface SubscriptionPlanData {
        name: string;
        description: string;
        monthlyPrice: number;
        annualPrice?: number;
        features: object; // JSONB
        isActive?: boolean;
    }

    export class InitialSubscriptionPlansSeed {
        public async run(dataSource: DataSource): Promise<any> {
            const planRepository = dataSource.getRepository('SubscriptionPlan'); // Or direct query

            const plansToSeed: SubscriptionPlanData[] = [
                {
                    name: 'Basic',
                    description: 'Limited features, free or low cost.',
                    monthlyPrice: 0.00,
                    features: { campaigns: 1, users: 1, analytics: 'basic' },
                    isActive: true,
                },
                {
                    name: 'Pro',
                    description: 'Advanced tools and higher limits.',
                    monthlyPrice: 49.99,
                    annualPrice: 499.99,
                    features: { campaigns: 10, users: 5, analytics: 'advanced', ab_testing: true },
                    isActive: true,
                },
                {
                    name: 'Plus',
                    description: 'Premium features and highest limits.',
                    monthlyPrice: 99.99,
                    annualPrice: 999.99,
                    features: { campaigns: 'unlimited', users: 'unlimited', analytics: 'premium', ab_testing: true, dedicated_support: true },
                    isActive: true,
                },
            ];

            for (const planData of plansToSeed) {
                const existingPlan = await planRepository.findOneBy({ name: planData.name });
                if (!existingPlan) {
                     await dataSource.createQueryBuilder()
                        .insert()
                        .into('SubscriptionPlan')
                        .values(planData)
                        .orIgnore()
                        .execute();
                    console.log(`Seeded plan: ${planData.name}`);
                } else {
                    console.log(`Plan already exists: ${planData.name}`);
                }
            }
        }
    }
    

## 7. Deployment and Execution
*   Migrations are typically run as part of the deployment pipeline (CI/CD) before the application starts.
*   The `migration:run` script will be executed in production environments.
*   Seed scripts (`seed:run`) are usually run once after initial setup or in development/testing environments to populate necessary data. Care must be taken if running seeds in production.
*   Environment variables for database connection (`DB_HOST`, `DB_PORT`, `DB_USERNAME`, `DB_PASSWORD`, `DB_DATABASE_NAME`) must be configured in the deployment environment.

## 8. DynamoDB Considerations (Future/Placeholder)
As per the repository description, this repository *may* include scripts for DynamoDB data model seeding or one-off transformations.
*   If such scripts are needed, they would likely be separate TypeScript files in a `database/dynamodb-scripts/` directory.
*   These scripts would use the AWS SDK for JavaScript (v3) to interact with DynamoDB.
*   They would not be managed by TypeORM migrations but by custom execution scripts defined in `package.json`.
*   Example tasks:
    *   Seeding initial data into `ProductFeedData`, `ABTestEventLog`, or `UserPreference` tables.
    *   Performing data transformations if the schema of a DynamoDB table evolves significantly.
*   No specific DynamoDB scripts are defined in the current `file_structure_json`, so this section remains a placeholder for potential future development.

## 9. Non-Functional Requirements
*   **Maintainability**: Achieved through version-controlled migrations, clear naming conventions, and separation of schema changes.
*   **Reliability**: Migration scripts should be robust and, where possible, transactional. `down` methods provide a path for rollback.
*   **Performance**: While migrations are typically run offline or during maintenance, inefficient DDL (especially on large tables) should be avoided. Index creation should be considered part_of migrations.

This SDS provides a comprehensive guide for developing, managing, and executing database migrations and seed scripts for the Ad Manager platform's PostgreSQL database.